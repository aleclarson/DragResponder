// Generated by CoffeeScript 1.12.4
var AnimatedValue, Event, Gesture, LazyVar, OneOf, Responder, ResponderSyntheticEvent, Type, emptyFunction, type;

AnimatedValue = require("Animated").AnimatedValue;

Responder = require("gesture").Responder;

ResponderSyntheticEvent = require("react-native/lib/ResponderSyntheticEvent");

emptyFunction = require("emptyFunction");

LazyVar = require("LazyVar");

OneOf = require("OneOf");

Event = require("eve");

Type = require("Type");

Gesture = require("./Gesture");

type = Type("DragResponder");

type.inherits(Responder);

type.defineArgs(function() {
  return {
    required: true,
    types: {
      axis: OneOf("x y"),
      offset: Number.or(AnimatedValue),
      captureDistance: Number,
      canDrag: Function,
      shouldRespondOnStart: Function,
      shouldCaptureOnMove: Function
    },
    defaults: {
      offset: 0,
      captureDistance: 10,
      canDrag: emptyFunction.thatReturnsTrue,
      shouldRespondOnStart: emptyFunction.thatReturnsFalse,
      shouldCaptureOnMove: emptyFunction.thatReturnsTrue
    }
  };
});

type.defineStatics({
  Gesture: Gesture
});

type.defineFrozenValues(function(options) {
  return {
    axis: options.axis,
    offset: this._createOffset(options.offset),
    isHorizontal: options.axis === "x",
    _captureDistance: options.captureDistance,
    _lockedAxis: LazyVar((function(_this) {
      return function() {
        var dx, dy, gesture;
        gesture = _this._gesture;
        dx = Math.abs(gesture.dx);
        dy = Math.abs(gesture.dy);
        if (_this._isAxisDominant(dx, dy)) {
          return "x";
        }
        if (_this._isAxisDominant(dy, dx)) {
          return "y";
        }
        return null;
      };
    })(this))
  };
});

type.defineValues(function(options) {
  return {
    lastVelocity: null,
    _canDrag: options.canDrag
  };
});

type.defineMethods({
  _createOffset: function(offset) {
    if (offset instanceof AnimatedValue) {
      return offset;
    }
    return AnimatedValue(offset);
  },
  _isAxisDominant: function(a, b) {
    return (a - 2) > b && (a >= this._captureDistance);
  },
  _canDragOnStart: function() {
    if (this._canDrag(this._gesture)) {
      return true;
    }
    this.terminate();
    return false;
  },
  _canDragOnMove: function() {
    var lockedAxis;
    if (!this._canDrag(this._gesture)) {
      this.terminate();
      return false;
    }
    lockedAxis = this._lockedAxis.get();
    if (lockedAxis === null) {
      this._lockedAxis.reset();
      return false;
    }
    if (lockedAxis !== this.axis) {
      this.terminate();
      return false;
    }
    return true;
  }
});

type.overrideMethods({
  __createGesture: function(options) {
    options.axis = this.axis;
    options.startOffset = this.offset.get();
    return Gesture(options);
  },
  __shouldRespondOnStart: function() {
    if (!this._canDragOnStart()) {
      return false;
    }
    return this.__super(arguments);
  },
  __shouldRespondOnMove: function() {
    if (!this._canDragOnMove()) {
      return false;
    }
    return this.__super(arguments);
  },
  __shouldCaptureOnStart: function() {
    if (!this._canDragOnStart()) {
      return false;
    }
    return this.__super(arguments);
  },
  __shouldCaptureOnMove: function() {
    if (!this._canDragOnMove()) {
      return false;
    }
    return this.__super(arguments);
  },
  __onTouchMove: function(event) {
    var gesture;
    gesture = this._gesture;
    gesture.__onTouchMove(event);
    this._isGranted && this.offset.set(gesture.startOffset + gesture.distance);
    this.didTouchMove.emit(gesture);
  },
  __onTouchEnd: function() {
    if (this._touchCount === 0) {
      this._lockedAxis.reset();
    }
    return this.__super(arguments);
  },
  __onGrant: function() {
    var gesture;
    gesture = this._gesture;
    this.lastVelocity = null;
    this.offset.stopAnimation();
    this.__super(arguments);
    this._lockedAxis.set(this.axis);
    gesture.startOffset = this.offset.get() - gesture.distance;
  },
  __onRelease: function() {
    this.lastVelocity = this._gesture.velocity;
    return this.__super(arguments);
  }
});

module.exports = type.build();
